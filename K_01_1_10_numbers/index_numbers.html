<!doctype html>
<html lang="en">
<head>
  <link rel="preload" as="font" type="font/woff2" href="../font/WenKai-Regular.woff2" crossorigin>
  <style>
  @font-face {
    font-family: 'WenKai';
    src: url('../font/WenKai-Regular.woff2') format('woff2'),
         url('../font/WenKai-Regular.woff') format('woff');
    font-weight: 400;
    font-style: normal;
    font-display: swap;
  }
</style>

<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My characters</title>
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<style>
:root{--layout-w:min(1200px,98vw);--sidebar-w:220px}
html,body{height:100%}
body{margin:0;background:#f6f7fb;font-family:-apple-system,system-ui,"PingFang SC","Noto Sans CJK SC","KaiTi","Kaiti SC","STKaiti",serif;display:grid;place-items:center}
.layout{width:var(--layout-w);display:grid;grid-template-columns:var(--sidebar-w) 1fr;gap:14px;padding:14px}
.sidebar{background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.06);padding:10px;overflow:auto;max-height:86vh}
.sidebar h3{margin:8px 8px 10px;font-size:16px;color:#444;display:flex;justify-content:space-between;align-items:center}
.charList{list-style:none;padding:0;margin:0}
.charList li{display:flex;align-items:center;gap:10px;padding:8px 10px;margin:6px 4px;border-radius:12px;cursor:pointer}
.charList li:hover{background:#f1f3f7}
.charList li.active{background:#e7eefc;box-shadow:inset 0 0 0 2px #d0dcff}
.charList .han{font-family:'WenKai','KaiTi','Kaiti SC','STKaiti',serif;font-size:28px;width:38px;text-align:center}
.charList .meta{display:flex;flex-direction:column;line-height:1.1}
.charList .meta .py{font-size:12px;color:#555}
.charList .meta .en{font-size:11px;color:#777}
.card{background:#fff;border-radius:24px;box-shadow:0 12px 40px rgba(0,0,0,.08);padding:20px;max-height:86vh;overflow:auto}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:6px}
.idx{font-size:14px;color:#666}
.row{display:grid;grid-template-columns:auto 240px;gap:12px;align-items:center;justify-content:center}
.mainCol{display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:240px}
.hanzi{font-family:'WenKai','KaiTi','Kaiti SC','STKaiti',serif;font-size:clamp(110px,18vw,160px);line-height:1;margin:2px 0 6px;text-align:center}
.pinyin{font-size:26px;font-weight:700;line-height:1.05;text-align:center;margin:0}
.meaning{color:#666;margin:4px 0 0;text-align:center;line-height:1.05}
.anim,.video{width:240px;height:240px;display:block;border-radius:16px;object-fit:cover;background:#f0f2f7;margin:0 auto}
.controls{display:flex;justify-content:center;gap:12px;margin-top:8px;flex-wrap:wrap}
.controls button{font-size:16px;padding:10px 14px;border:0;border-radius:12px;background:#eef0f4}
.traceWrap{margin-top:16px}
.traceHead{display:flex;justify-content:space-between;align-items:center;margin:8px 2px 10px}
.traceGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
.traceCell{position:relative;background:#fafbff;border-radius:14px;padding:8px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.06)}
canvas.trace{width:140px;height:140px;touch-action:none;display:block;margin:0 auto}
.traceClear{position:absolute;top:6px;right:6px;font-size:10px;line-height:1;border:0;border-radius:6px;padding:4px 6px;background:#eef0f4;cursor:pointer}
.nav{display:flex;justify-content:space-between;padding:10px 2px 0}
.nav button{min-width:120px}
body.saving .controls, body.saving .nav, body.saving .traceClear{visibility:hidden}
@media (max-width:960px){:root{--sidebar-w:170px}.row{grid-template-columns:1fr}.mainCol{min-height:unset}.traceGrid{grid-template-columns:repeat(2,1fr)}}
@media (max-width:540px){.layout{grid-template-columns:1fr}.sidebar{max-height:220px}.traceGrid{grid-template-columns:1fr}}
</style>

<style>
/* layout helpers (non-destructive) */
.row.layout-enhanced { gap: 16px; align-items: flex-start; margin-top: 16px; }
.sideCol { display: flex; flex-direction: column; gap: 8px; align-items: stretch; }
.mediaWrap { display: flex; align-items: center; gap: 12px; }
.saveCol { display: flex; flex-direction: column; }
.traceWrap { margin-bottom: 12px; } /* space below tracing grid */
.sideCol button, .saveCol button { white-space: nowrap; }
</style>

<script>
document.addEventListener('DOMContentLoaded', function(){
  try {
    const trace = document.querySelector('.traceWrap');
    const row = document.querySelector('.row');
    if (trace && row && trace !== row.previousElementSibling) {
      row.parentNode.insertBefore(trace, row); // put tracing above row
    }

    if (row) row.classList.add('layout-enhanced');

    // Prepare side column for three controls
    const sideCol = document.createElement('div');
    sideCol.className = 'sideCol';

    // Find existing buttons by id
    const play = document.getElementById('playBtn');
    const pin = document.getElementById('togglePinyinBtn');
    const eng = document.getElementById('toggleMeaningBtn');

    // A helper to move an element if found
    function moveIf(el){ if(el){ sideCol.appendChild(el); } }

    // Find a reasonable insertion point: before the main char column
    const mainCol = document.querySelector('.row .mainCol');
    if (mainCol) {
      row.insertBefore(sideCol, mainCol);
    } else {
      row.insertBefore(sideCol, row.firstChild);
    }

    moveIf(play);
    moveIf(pin);
    moveIf(eng);

    // If the original controls container is now empty, hide it
    const controls = document.querySelector('.controls');
    if (controls && controls.children.length === 0) {
      controls.style.display = 'none';
    }

    // Wrap media (img/video) and put Save button to the right
    const saveBtn = document.getElementById('saveBtn');
    const animImg = document.getElementById('animImg');
    const video = document.querySelector('video, .videoWrap');

    // Prefer image; if not, try video
    const mediaEl = animImg || video;
    if (mediaEl) {
      // If mediaEl is already inside a parent container, we can wrap that parent
      let container = mediaEl.parentElement;
      // Create a wrapper
      const wrap = document.createElement('div');
      wrap.className = 'mediaWrap';

      // Insert wrapper before the container, then move container inside wrap
      container.parentNode.insertBefore(wrap, container);
      wrap.appendChild(container);

      // Now add save button on the right if present
      if (saveBtn) {
        const saveCol = document.createElement('div');
        saveCol.className = 'saveCol';
        saveCol.appendChild(saveBtn);
        wrap.appendChild(saveCol);
      }
    }
  } catch (e) {
    console.warn('Layout enhancement failed:', e);
  }
});
</script>


<style>
/* Narrow side buttons to match old width */
.sideCol { align-items: flex-start; }
.sideCol button {
  width: auto;
  min-width: 0;
  align-self: flex-start;
  display: inline-block;
}
</style>


<style>
/* Spacing: reduce gap between columns in the main row */
.row.layout-enhanced {
  column-gap: 8px;
  gap: 8px;
}

/* Align media area and save button to the top (same line as Play button) */
.mediaWrap {
  align-items: flex-start;   /* top align image/video and save column */
  gap: 8px;                  /* tighter spacing */
}

/* Make sure the Save Image column starts at the very top and doesn't stretch */
.saveCol {
  align-self: flex-start;
  justify-content: flex-start;
  margin-top: 0;
  padding-top: 0;
}

/* Extra safety: avoid unintended margins inside wrapper children */
.mediaWrap > * {
  margin-top: 0 !important;
}

/* Keep side buttons compact and top-aligned (from previous step) */
.sideCol { align-items: flex-start; }
.sideCol button { width: auto; min-width: 0; align-self: flex-start; display: inline-block; }
</style>


<style>
/* Force the main row into a tight 3-column grid: [buttons] [main char] [media+save] */
.row.layout-enhanced {
  display: grid !important;
  grid-template-columns: auto 1fr auto !important;
  justify-content: flex-start !important;
  align-items: start !important;
  column-gap: 8px !important;
  gap: 8px !important;
}

/* Ensure inner blocks don't introduce extra margins */
.row.layout-enhanced > * { margin: 0 !important; }
.mediaWrap { align-items: flex-start !important; gap: 8px !important; }
.saveCol { align-self: flex-start !important; }
.sideCol { align-items: flex-start !important; }
.sideCol button { width: auto !important; min-width: 0 !important; }
</style>


<style>
/* Make columns hug content: [buttons] [main (shrink)] [media+save] */
.row.layout-enhanced {
  grid-template-columns: auto max-content auto !important;
  column-gap: 3px !important; /* ~1/3 of previous 8px */
  gap: 3px !important;
}

/* Prevent middle from stretching */
.row.layout-enhanced .mainCol {
  width: auto !important;
  max-width: none !important;
}
</style>


<style>
/* Ultra-compact spacing between the first and second columns */
.row.layout-enhanced {
  column-gap: 2px !important;
  gap: 2px !important;
  justify-items: start !important;
}
/* Remove any side padding/margins that could add hidden space */
.sideCol, .mainCol {
  margin: 0 !important;
  padding: 0 !important;
}
/* Ensure buttons don't reserve extra space */
.sideCol button {
  margin: 0 !important;
}
/* Ensure the big character block doesn't add inner spacing */
.mainCol > * {
  margin-top: 0 !important;
  margin-left: 0 !important;
}
</style>


<style>
/* Shift entire row right by half the Play button width; increase col gap to 4px */
.row.layout-enhanced {
  margin-left: var(--rowOffset, 0px) !important;
  column-gap: 4px !important;
  gap: 4px !important;
}
</style>

<script>
(function(){
  function setRowOffset(){
    var play = document.getElementById('playBtn');
    var row = document.querySelector('.row.layout-enhanced') || document.querySelector('.row');
    if(!play || !row) return;
    var half = Math.round(play.getBoundingClientRect().width / 2);
    row.style.setProperty('--rowOffset', half + 'px');
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setRowOffset);
  } else {
    setRowOffset();
  }
  window.addEventListener('resize', setRowOffset);
})();
</script>


<script>
(function(){
  function isSingleChar(text){
    if(!text) return false;
    const s = text.trim();
    // Treat 1 visible codepoint as "single char"
    return [...s].length === 1;
  }
  function matchMainColWidth(){
    const hanzi = document.getElementById('hanzi');
    const mainCol = document.querySelector('.mainCol');
    const row = document.querySelector('.row');
    if(!hanzi || !mainCol || !row) return;
    if(!isSingleChar(hanzi.textContent)) {
      mainCol.style.minWidth = '';
      return;
    }
    // Prefer image width; fallback to video width
    const img = document.getElementById('animImg');
    const video = document.querySelector('video');
    let w = 0;
    if (img && img.offsetWidth) w = img.offsetWidth;
    else if (video && video.offsetWidth) w = video.offsetWidth;
    if (w > 0) {
      mainCol.style.minWidth = w + 'px';
    }
  }
  function onReady(fn){
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', fn);
    else fn();
  }
  onReady(function(){
    matchMainColWidth();
    // Recompute when image loads or on resize
    const img = document.getElementById('animImg');
    if (img) {
      img.addEventListener('load', matchMainColWidth, { once:false });
    }
    window.addEventListener('resize', matchMainColWidth);
  });
})();
</script>

</head>
<body>
<div class="layout">
  <aside class="sidebar">
    <h3>My characters <a href="../main.html" id="homeLink" style="font-size:12px;color:#3366cc;text-decoration:underline;">üè† Home</a></h3>
    <ul id="charList" class="charList"></ul>
  </aside>

  <main class="card" id="cardRoot">
    <div class="top">
      <div class="idx" id="idx"> 1 / 10 </div>
      <div class="idx" id="hint">Tap üîä for audio</div>
    </div>

    <div class="row">
      <div class="mainCol">
        <div class="hanzi"   id="hanzi"></div>
        <div class="pinyin"  id="pinyin"></div>
        <div class="meaning" id="meaning"></div>
      </div>
      <div>
        <img   id="animImg" class="anim" style="display:none"/>
        <video id="animVid" class="video" muted loop playsinline style="display:none"></video>
      </div>
    </div>

    <audio id="audio" preload="auto"><source id="srcWav" type="audio/wav"></source></audio>

    <div class="controls">
      <button id="playBtn">üîä Play</button>
      <button id="togglePinyinBtn">Pinyin</button>
      <button id="toggleMeaningBtn">English</button>
      <button id="saveBtn">üíæ Save Image</button>
    </div>

    <div class="traceWrap">
      <div class="traceHead">
        <div style="font-weight:700">Trace practice</div>
        <div><button id="clearAllBtn">Clear All</button></div>
      </div>
      <div class="traceGrid" id="traceGrid">
        <div class="traceCell"><button class="traceClear" data-i="0">‚úï</button><canvas class="trace guided" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="1">‚úï</button><canvas class="trace guided" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="2">‚úï</button><canvas class="trace guided" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="3">‚úï</button><canvas class="trace guided" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="4">‚úï</button><canvas class="trace guided" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="5">‚úï</button><canvas class="trace free" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="6">‚úï</button><canvas class="trace free" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="7">‚úï</button><canvas class="trace free" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="8">‚úï</button><canvas class="trace free" width="140" height="140"></canvas></div>
        <div class="traceCell"><button class="traceClear" data-i="9">‚úï</button><canvas class="trace free" width="140" height="140"></canvas></div>
      </div>
    </div>

    <div class="nav">
      <button id="prevBtn">‚Üê Prev</button>
      <button id="nextBtn">Next ‚Üí</button>
    </div>
  </main>
</div>

<script>
// numbers ignored; we use the extracted family deck
window.DECK = [
  {"hanzi":"‰∏Ä","pinyin":"yƒ´","meaning":"one",  "audio":"audio/yi1.wav",  "media":"media/yi1.gif",  "order":1, "include":true},
  {"hanzi":"‰∫å","pinyin":"√®r","meaning":"two",  "audio":"audio/er4.wav",  "media":"media/er4.gif",  "order":2, "include":true},
  {"hanzi":"‰∏â","pinyin":"sƒÅn","meaning":"three","audio":"audio/san1.wav","media":"media/san1.gif","order":3, "include":true},
  {"hanzi":"Âõõ","pinyin":"s√¨","meaning":"four", "audio":"audio/si4.wav",  "media":"media/si4.gif",  "order":4, "include":true},
  {"hanzi":"‰∫î","pinyin":"w«î","meaning":"five", "audio":"audio/wu3.wav",  "media":"media/wu3.gif",  "order":5, "include":true},
  {"hanzi":"ÂÖ≠","pinyin":"li√π","meaning":"six", "audio":"audio/liu4.wav", "media":"media/liu4.gif", "order":6, "include":true},
  {"hanzi":"‰∏É","pinyin":"qƒ´","meaning":"seven","audio":"audio/qi1.wav",  "media":"media/qi1.gif",  "order":7, "include":true},
  {"hanzi":"ÂÖ´","pinyin":"bƒÅ","meaning":"eight","audio":"audio/ba1.wav",  "media":"media/ba1.gif",  "order":8, "include":true},
  {"hanzi":"‰πù","pinyin":"ji«î","meaning":"nine","audio":"audio/jiu3.wav","media":"media/jiu3.gif","order":9, "include":true},
  {"hanzi":"ÂçÅ","pinyin":"sh√≠","meaning":"ten", "audio":"audio/shi2.wav","media":"media/shi2.gif","order":10,"include":true}
];

const DPR=Math.max(1,Math.min(3,window.devicePixelRatio||1));
let deck=window.DECK.slice(), idx=0;
const elH=document.getElementById('hanzi'),
      elP=document.getElementById('pinyin'),
      elM=document.getElementById('meaning'),
      elI=document.getElementById('idx'),
      audio=document.getElementById('audio'),
      srcWav=document.getElementById('srcWav'),
      animImg=document.getElementById('animImg'),
      animVid=document.getElementById('animVid'),
      charList=document.getElementById('charList');
const traces=Array.from(document.querySelectorAll('canvas.trace'));

function renderSidebar(a){
  charList.innerHTML='';
  deck.forEach((c,i)=>{
    const li=document.createElement('li');
    li.className=i===a?'active':'';
    li.innerHTML='<div class="han">'+(c.hanzi||'')+'</div><div class="meta"><span class="py">'+(c.pinyin||'')+'</span><span class="en">'+(c.meaning||'')+'</span></div>';
    li.addEventListener('click',()=>show(i));
    charList.appendChild(li);
  });
}

function drawGrid(ctx,w,h){
  ctx.clearRect(0,0,w,h);
  ctx.save();
  ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=1*DPR; ctx.strokeRect(0.5*DPR,0.5*DPR,w-1*DPR,h-1*DPR);
  ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.moveTo(0,h/2); ctx.lineTo(w,h/2);
  ctx.strokeStyle='rgba(0,0,0,0.18)'; ctx.lineWidth=1*DPR; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(w,h); ctx.moveTo(w,0); ctx.lineTo(0,h);
  ctx.strokeStyle='rgba(0,0,0,0.12)'; ctx.stroke(); ctx.restore();
}
function drawGuide(ctx,w,h,ch){
  drawGrid(ctx,w,h);
  if(!ch) return;
  ctx.save(); ctx.globalAlpha=0.22; ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.textBaseline='middle';
  var f=Math.floor(h*0.72); ctx.font = f+'px WenKai, KaiTi, "Kaiti SC", STKaiti, serif';
  ctx.fillText(ch, w/2, h/2); ctx.restore();
}

function setupAll(displayWord){
  const chars = Array.from(displayWord||"");
  const L = chars.length;
  traces.forEach((cnv,i)=>{
    const isGuided = cnv.classList.contains('guided');
    let ch = "";
    if (isGuided){
      if (L >= 2){
        ch = (i < 4) ? (chars[i % L] || "") : ""; // first 4 cycle, 5th empty
      } else if (L === 1){
        ch = (i < 5) ? chars[0] : ""; // single char fills all 5
      } else {
        ch = "";
      }
    }
    const cssW=cnv.clientWidth, cssH=cnv.clientHeight;
    cnv.width=Math.floor(cssW*DPR); cnv.height=Math.floor(cssH*DPR);
    const ctx=cnv.getContext('2d');
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='rgba(220,30,30,1)'; ctx.lineWidth=6*DPR;
    if(isGuided) drawGuide(ctx, cnv.width, cnv.height, ch); else drawGrid(ctx, cnv.width, cnv.height);
    let drawing=false,last=null;
    function xy(ev){const r=cnv.getBoundingClientRect();let x,y;
      if(ev.touches&&ev.touches[0]){x=(ev.touches[0].clientX-r.left)*DPR;y=(ev.touches[0].clientY-r.top)*DPR;}
      else if(ev.changedTouches&&ev.changedTouches[0]){x=(ev.changedTouches[0].clientX-r.left)*DPR;y=(ev.changedTouches[0].clientY-r.top)*DPR;}
      else{x=(ev.clientX-r.left)*DPR;y=(ev.clientY-r.top)*DPR;} return{x,y};
    }
    function start(e){e.preventDefault();drawing=true;last=xy(e);}
    function move(e){if(!drawing)return;e.preventDefault();const p=xy(e);const c2=cnv.getContext('2d');c2.beginPath();c2.moveTo(last.x,last.y);c2.lineTo(p.x,p.y);c2.stroke();last=p;}
    function end(e){if(!drawing)return;e.preventDefault();drawing=false;}
    cnv.addEventListener('pointerdown',start); cnv.addEventListener('pointermove',move); cnv.addEventListener('pointerup',end); cnv.addEventListener('pointerleave',end);
    cnv.addEventListener('mousedown',start); window.addEventListener('mousemove',(e)=>{ if(drawing) move(e); }); window.addEventListener('mouseup',end);
    cnv.addEventListener('touchstart',start,{passive:false}); cnv.addEventListener('touchmove',move,{passive:false}); cnv.addEventListener('touchend',end,{passive:false});
  });
}
function clearAll(){
  const currentWord = (document.getElementById('hanzi')||{}).textContent || '';
  const chars = Array.from(currentWord||"");
  const L = chars.length;
  traces.forEach((cnv,i)=>{
    const ctx=cnv.getContext('2d');
    const isGuided = cnv.classList.contains('guided');
    let ch = "";
    if (isGuided){
      if (L >= 2){
        ch = (i < 4) ? (chars[i % L] || "") : "";
      } else if (L === 1){
        ch = (i < 5) ? chars[0] : "";
      } else {
        ch = "";
      }
    }
    if(isGuided) drawGuide(ctx, cnv.width, cnv.height, ch); else drawGrid(ctx, cnv.width, cnv.height);
  });
}

function bust(u){ if(!u) return u; const j=u.indexOf('?')>=0?'&':'?'; return u+j+'v='+Date.now(); }
function media(path){
  animImg.style.display='none'; animVid.style.display='none'; animVid.pause();
  if(!path) return;
  const ext=(path.split('.').pop()||'').toLowerCase();
  if(['mp4','mov','webm'].includes(ext)){ animVid.src=bust(path); animVid.style.display='block'; animVid.play().catch(()=>{}); }
  else { animImg.src=bust(path); animImg.style.display='block'; }
}

function show(i){
  idx=(i+deck.length)%deck.length;
  const c=deck[idx]||{};
  document.getElementById('hanzi').textContent=c.hanzi||'';
  document.getElementById('pinyin').textContent=c.pinyin||'';
  document.getElementById('meaning').textContent=c.meaning||'';
  document.getElementById('idx').textContent=(idx+1)+' / '+deck.length;
  media(c.media);
  if(c.audio){ srcWav.src=bust(c.audio); audio.load(); }
  setupAll(c.hanzi||'');
  renderSidebar(idx);
}

document.getElementById('playBtn').addEventListener('click',async()=>{ try{ await audio.play(); }catch(e){ alert('Audio could not play.'); } });
document.getElementById('togglePinyinBtn').addEventListener('click',()=>{
  const el=document.getElementById('pinyin'); el.style.visibility=(el.style.visibility==='hidden')?'visible':'hidden';
});
document.getElementById('toggleMeaningBtn').addEventListener('click',()=>{
  const el=document.getElementById('meaning'); el.style.visibility=(el.style.visibility==='hidden')?'visible':'hidden';
});
document.getElementById('prevBtn').addEventListener('click',()=>show(idx-1));
document.getElementById('nextBtn').addEventListener('click',()=>show(idx+1));
document.getElementById('clearAllBtn').addEventListener('click',clearAll);
document.querySelectorAll('.traceClear').forEach(btn=>{
  btn.addEventListener('click',(e)=>{
    e.preventDefault(); e.stopPropagation();
    const i=parseInt(btn.getAttribute('data-i'),10)||0;
    const cnv=document.querySelectorAll('canvas.trace')[i];
    if(!cnv) return;
    const ctx=cnv.getContext('2d');
    const isGuided = cnv.classList.contains('guided');
    const currentWord = (document.getElementById('hanzi')||{}).textContent || '';
    const chars = Array.from(currentWord||"");
    let ch = "";
    if (isGuided){
      if (chars.length >= 2){ ch = (i < 4) ? (chars[i % chars.length] || "") : ""; }
      else if (chars.length === 1){ ch = (i < 5) ? chars[0] : ""; }
      else { ch = ""; }
    }
    if(isGuided) drawGuide(ctx, cnv.width, cnv.height, ch); else drawGrid(ctx, cnv.width, cnv.height);
  });
});

// draw grids early to avoid blank look before first show()
document.addEventListener('DOMContentLoaded', ()=>{
  traces.forEach(c=>{
    const ctx=c.getContext('2d');
    drawGrid(ctx, c.width||140, c.height||140);
  });
  if(deck.length){ show(0); }
});
</script>

<script>
(function(){
  
function exportTraceGridPNG(){
  const grid = document.querySelector('.traceGrid');
  const hanziEl = document.getElementById('hanzi');
  const charText = (hanziEl && hanziEl.textContent.trim()) || '';
  const name = charText || 'card';
  if(!grid){
    alert('No tracing grid found to save.');
    return;
  }
  const canvases = Array.from(grid.querySelectorAll('canvas'));
  if (!canvases.length){
    alert('No canvases to export.');
    return;
  }
  // Determine cell size from first canvas
  const cw = canvases[0].width, ch = canvases[0].height;
  // Default 5 columns
  const cols = Math.min(5, canvases.length);
  const rows = Math.ceil(canvases.length / cols);
  const pad = 8; // padding around cells
  // Header band for big character
  const headerH = Math.max(160, Math.floor(ch * 1.2)); // proportional header
  const W = cols * cw + (cols + 1) * pad;
  const H = headerH + (rows * ch + (rows + 1) * pad);

  const out = document.createElement('canvas');
  out.width = W; out.height = H;
  const ctx = out.getContext('2d');

  // Background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);

  // --- Draw big character in header (centered) ---
  if (charText) {
    // Try to match page font
    ctx.fillStyle = '#000000';
    // Choose font size to roughly match cell size
    const f = Math.floor(headerH * 0.7);
    ctx.font = `bold ${f}px WenKai, KaiTi, "Kaiti SC", STKaiti, serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(charText, W / 2, Math.floor(headerH * 0.52));
  }

  // --- Draw trace canvases ---
  canvases.forEach((c,i)=>{
    const r = Math.floor(i / cols), k = i % cols;
    const x = pad + k * (cw + pad);
    const y = headerH + pad + r * (ch + pad);
    try { ctx.drawImage(c, x, y); } catch(e) {}
  });

  // --- Timestamp at bottom-right ---
  try {
    const ts = new Date().toLocaleString();
    ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle = '#333';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText(ts, W - 8, H - 8);
  } catch (e) {}

  // Download
  const a = document.createElement('a');
  a.href = out.toDataURL('image/png');
  a.download = name + '_card.png';
  a.click();
}
const canvases = Array.from(grid.querySelectorAll('canvas'));
    if (!canvases.length){
      alert('No canvases to export.');
      return;
    }
    // Determine cell size from first canvas
    const cw = canvases[0].width, ch = canvases[0].height;
    // Determine columns/rows: default 5 cols, ceil(n/5) rows
    const cols = Math.min(5, canvases.length);
    const rows = Math.ceil(canvases.length / cols);
    // Offscreen canvas
    const pad = 8; // small padding around cells
    const W = cols * cw + (cols + 1) * pad;
    const H = rows * ch + (rows + 1) * pad;
    const out = document.createElement('canvas');
    out.width = W; out.height = H;
    const ctx = out.getContext('2d');
    // white background for better print/export
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,H);
    // draw each cell
    canvases.forEach((c,i)=>{
      const r = Math.floor(i / cols), k = i % cols;
      const x = pad + k * (cw + pad);
      const y = pad + r * (ch + pad);
      try { ctx.drawImage(c, x, y); } catch(e) {}
    });
    // Download
    const a = document.createElement('a');
    a.href = out.toDataURL('image/png');
    a.download = name + '_trace.png';
    a.click();
  }

  function wire(){
    const btn = document.getElementById('saveBtn');
    if(!btn) return;
    // Avoid double binding
    if (!btn.dataset._saveWired) {
      btn.addEventListener('click', exportTraceGridPNG);
      btn.dataset._saveWired = '1';
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wire);
  } else {
    wire();
  }
})();
</script>


<script>
(function(){
  // Override export function to use toBlob + object URL (more reliable for downloads)
  function exportTraceGridPNG(){
    const grid = document.querySelector('.traceGrid');
    const hanziEl = document.getElementById('hanzi');
    const charText = (hanziEl && hanziEl.textContent.trim()) || '';
    const name = charText || 'card';
    if (!grid) { alert('No tracing grid found to save.'); return; }
    const canvases = Array.from(grid.querySelectorAll('canvas'));
    if (!canvases.length) { alert('No canvases to export.'); return; }

    const cw = canvases[0].width, ch = canvases[0].height;
    const cols = Math.min(5, canvases.length);
    const rows = Math.ceil(canvases.length / cols);
    const pad = 8;
    const headerH = Math.max(160, Math.floor(ch * 1.2));
    const W = cols * cw + (cols + 1) * pad;
    const H = headerH + (rows * ch + (rows + 1) * pad);

    const out = document.createElement('canvas');
    out.width = W; out.height = H;
    const ctx = out.getContext('2d');

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,H);

    if (charText) {
      const f = Math.floor(headerH * 0.7);
      ctx.fillStyle = '#000';
      ctx.font = 'bold ' + f + 'px WenKai, KaiTi, "Kaiti SC", STKaiti, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(charText, W/2, Math.floor(headerH * 0.52));
    }

    canvases.forEach((c,i)=>{
      const r = Math.floor(i / cols), k = i % cols;
      const x = pad + k * (cw + pad);
      const y = headerH + pad + r * (ch + pad);
      try { ctx.drawImage(c, x, y); } catch(e) {}
    });

    try {
      const ts = new Date().toLocaleString();
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(ts, W - 8, H - 8);
    } catch(e){}

    function triggerDownload(blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name + '_card.png';
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    }

    if (out.toBlob) {
      out.toBlob(triggerDownload, 'image/png');
    } else {
      // Fallback for older browsers
      const a = document.createElement('a');
      a.href = out.toDataURL('image/png');
      a.download = name + '_card.png';
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
  }

  // Ensure the save button is wired to this latest function
  function wire(){
    const btn = document.getElementById('saveBtn');
    if(!btn) return;
    btn.onclick = null;
    btn.removeEventListener && btn.removeEventListener('click', exportTraceGridPNG);
    btn.addEventListener('click', exportTraceGridPNG);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', wire);
  } else {
    wire();
  }
})();
</script>

</body>
</html>
